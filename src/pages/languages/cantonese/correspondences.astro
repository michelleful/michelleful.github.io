---
import Layout from '../../../layouts/Layout.astro';
import correspondences from './correspondences.json';
import fs from 'node:fs';

function cellColor(pct: number) {
  if (pct === 0) return 'transparent';
  const alpha = Math.min(pct / 80, 1) * 0.85 + 0.1;
  return `rgba(180, 90, 0, ${alpha})`;
}

function textColor(pct: number) {
  return pct > 40 ? '#fff' : '#333';
}

const components = ['initial', 'final', 'tone'] as const;
const directions = [
  { key: 'c2m', matrixKey: 'matrix_c2m', dirKey: 'cantonese_to_mandarin', srcLabel: 'Cantonese', tgtLabel: 'Mandarin', label: 'Cantonese → Mandarin' },
  { key: 'm2c', matrixKey: 'matrix_m2c', dirKey: 'mandarin_to_cantonese', srcLabel: 'Mandarin', tgtLabel: 'Cantonese', label: 'Mandarin → Cantonese' },
] as const;

// Compute prediction accuracy stats from readings data
import path from 'node:path';
const tsvPath = path.join(process.cwd(), 'src/pages/languages/cantonese/readings.tsv');
const tsvContent = fs.readFileSync(tsvPath, 'utf-8');
const tsvLines = tsvContent.trim().split('\n');
const headers = tsvLines[0].split('\t');
const readings = tsvLines.slice(1).map(line => {
  const cols = line.split('\t');
  const row: Record<string, string> = {};
  headers.forEach((h, i) => row[h] = cols[i] || '');
  row.mandarin_syllable = row.mandarin_initial + row.mandarin_final;
  row.cantonese_syllable = row.cantonese_initial + row.cantonese_final;
  return row;
});

function buildMostLikely(srcKey: string, tgtKey: string) {
  const counts: Record<string, Record<string, number>> = {};
  for (const r of readings) {
    const s = r[srcKey], t = r[tgtKey];
    if (!counts[s]) counts[s] = {};
    counts[s][t] = (counts[s][t] || 0) + 1;
  }
  const best: Record<string, string> = {};
  for (const [s, tgts] of Object.entries(counts)) {
    best[s] = Object.entries(tgts).sort((a, b) => b[1] - a[1])[0][0];
  }
  return best;
}

function accuracy(best: Record<string, string>, srcKey: string, tgtKey: string) {
  const correct = readings.filter(r => best[r[srcKey]] === r[tgtKey]).length;
  return (100 * correct / readings.length).toFixed(1);
}

const total = readings.length;

const stats = {
  m2c: {
    initial: accuracy(buildMostLikely('mandarin_initial', 'cantonese_initial'), 'mandarin_initial', 'cantonese_initial'),
    final: accuracy(buildMostLikely('mandarin_final', 'cantonese_final'), 'mandarin_final', 'cantonese_final'),
    initialFinal: (() => {
      const bi = buildMostLikely('mandarin_initial', 'cantonese_initial');
      const bf = buildMostLikely('mandarin_final', 'cantonese_final');
      const correct = readings.filter(r => bi[r.mandarin_initial] === r.cantonese_initial && bf[r.mandarin_final] === r.cantonese_final).length;
      return (100 * correct / total).toFixed(1);
    })(),
    syllable: accuracy(buildMostLikely('mandarin_syllable', 'cantonese_syllable'), 'mandarin_syllable', 'cantonese_syllable'),
    tone: accuracy(buildMostLikely('mandarin_tone', 'cantonese_tone'), 'mandarin_tone', 'cantonese_tone'),
  },
  c2m: {
    initial: accuracy(buildMostLikely('cantonese_initial', 'mandarin_initial'), 'cantonese_initial', 'mandarin_initial'),
    final: accuracy(buildMostLikely('cantonese_final', 'mandarin_final'), 'cantonese_final', 'mandarin_final'),
    initialFinal: (() => {
      const bi = buildMostLikely('cantonese_initial', 'mandarin_initial');
      const bf = buildMostLikely('cantonese_final', 'mandarin_final');
      const correct = readings.filter(r => bi[r.cantonese_initial] === r.mandarin_initial && bf[r.cantonese_final] === r.mandarin_final).length;
      return (100 * correct / total).toFixed(1);
    })(),
    syllable: accuracy(buildMostLikely('cantonese_syllable', 'mandarin_syllable'), 'cantonese_syllable', 'mandarin_syllable'),
    tone: accuracy(buildMostLikely('cantonese_tone', 'mandarin_tone'), 'cantonese_tone', 'mandarin_tone'),
  },
};
---

<Layout title="Cantonese-Mandarin Sound Correspondences">

<h1>Cantonese-Mandarin Sound Correspondences</h1>
<p>
  I heard Cantonese from a young age but never learned to speak it,
  and I learned Mandarin at school. So when I attempt to say a Cantonese word
  I don't already know, I'm often trying to take a Mandarin character and
  map it to its most likely Cantonese equivalent. And vice versa.
</p>
<p>
  This tool shows how successful this approach is likely to be
  in either direction, with tables demonstrating the
  phonological correspondences between the two languages.
  Data is from the
  <a href="https://www.unicode.org/reports/tr38/">Unihan database</a>
  which contains Mandarin (pinyin) and Cantonese (jyutping) readings.
</p>
<p>Prepared by <a href="/">Michelle Fullwood</a>.

<hr/>

<h3>How predictable are the correspondences?</h3>
<p>
  If you always guess the most likely correspondence, how often would you
  be right?
</p>
<p>
  Across {total.toLocaleString()} character readings:
</p>
<table class="stats-table">
  <thead>
    <tr>
      <th>Strategy</th>
      <th>M→C</th>
      <th>C→M</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Guess most likely <strong>initial</strong></td>
      <td>{stats.m2c.initial}%</td>
      <td>{stats.c2m.initial}%</td>
    </tr>
    <tr>
      <td>Guess most likely <strong>final</strong></td>
      <td>{stats.m2c.final}%</td>
      <td>{stats.c2m.final}%</td>
    </tr>
    <tr>
      <td>Guess <strong>syllable</strong> from most likely initial + most likely final</td>
      <td>{stats.m2c.initialFinal}%</td>
      <td>{stats.c2m.initialFinal}%</td>
    </tr>
    <tr>
      <td>Guess <strong>syllable</strong> from most likely whole syllable</td>
      <td>{stats.m2c.syllable}%</td>
      <td>{stats.c2m.syllable}%</td>
    </tr>
    <tr>
      <td>Guess most likely <strong>tone</strong></td>
      <td>{stats.m2c.tone}%</td>
      <td>{stats.c2m.tone}%</td>
    </tr>
  </tbody>
</table>

<p>
  This strategy is more successful in the Cantonese → Mandarin direction
  overall. Generally, Cantonese has been more conservative in preserving
  finals and tones from Middle Chinese, hence there are more possibilities
  for Cantonese finals and tones than in Mandarin. Choosing 
  from among more options is always going to be more difficult.
</p>

<p>
  The exception is in the initials, where Mandarin actually has more
  distinctions than Cantonese. For example, Mandarin palatalized
  its velars (g/k/h) and sibilants (z/c/s) into j/q/x before
  front vowels, creating a third series that Cantonese lacks.
  So going from Cantonese → Mandarin, each Cantonese initial
  like /g/ or /z/ could either stay as-is or become /j/ &mdash;
  more options to choose from, and thus harder to predict.
</p>

<p>
  Since the palatalization depends on the following vowel,
  knowing the final helps predict the initial. Similarly,
  knowing the initial helps predict the final.
  Which is why guessing the syllable as a unit does much better
  than guessing the initial and final independently.
</p>

<p>
  Having said that, this guessing approach isn't a dead-end. 
  There <strong>are</strong> reliable correspondences,
  you just need to have an instinct for which.
  The following tables may help!
</p>

<hr/>

<p>
  Select a direction and component to explore how initials, finals, tones,
  and full syllables map between the two languages.
</p>

<div class="controls">
  <div class="direction-toggle">
    {directions.map(d => (
      <button class={`dir-btn ${d.key === 'c2m' ? 'active' : ''}`} data-dir={d.key}>
        {d.label}
      </button>
    ))}
  </div>
  <div class="component-tabs">
    {['initial', 'final', 'tone', 'syllable'].map((tab, i) => (
      <button class={`tab-btn ${i === 0 ? 'active' : ''}`} data-tab={tab}>
        {tab[0].toUpperCase() + tab.slice(1)}
      </button>
    ))}
  </div>
</div>

<!-- Pre-rendered heatmap tables for initial, final, tone × 2 directions -->
{components.map(comp =>
  directions.map(dir => {
    const matrix = (correspondences as any)[comp][dir.matrixKey];
    return (
      <div class="heatmap-section" id={`heatmap-${dir.key}-${comp}`} hidden>
        <p class="matrix-caption">
          Rows: <span class="lang-name">{dir.srcLabel}</span> {comp}s.
          Columns: <span class="lang-name">{dir.tgtLabel}</span> {comp}s.
          <br/>Cell values show the percentage of characters with a given
          <span class="lang-name">{dir.srcLabel}</span> {comp} that have that <span class="lang-name">{dir.tgtLabel}</span> {comp}.
        </p>
        <div class="heatmap-scroll">
          <table class="heatmap">
            <thead>
              <tr>
                <th class="corner" colspan="2"></th>
                <th class="top-label" colspan={matrix.targets.length}>{dir.tgtLabel}</th>
              </tr>
              <tr>
                <th class="corner" colspan="2"></th>
                {matrix.targets.map((tgt: string) => (
                  <th class="col-header">{tgt || '∅'}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {matrix.sources.map((src: string, i: number) => (
                <tr>
                  {i === 0 && (
                    <th class="side-label" rowspan={matrix.sources.length}>
                      <div class="side-label-text">{dir.srcLabel}</div>
                    </th>
                  )}
                  <th class="row-header">{src || '∅'}</th>
                  {matrix.matrix[i].map((pct: number, j: number) => (
                    <td
                      class="cell"
                      style={`background-color: ${cellColor(pct)}; color: ${textColor(pct)}`}
                      title={`${src || '∅'} → ${matrix.targets[j] || '∅'}: ${pct}%`}
                    >
                      {pct >= 1 ? Math.round(pct) : ''}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
        <p class="scroll-hint" hidden>Scroll right to see more →</p>
      </div>
    );
  })
)}

<!-- Syllable section (populated by JS) -->
{directions.map(dir => (
  <div class="syllable-section" id={`syllable-${dir.key}`} hidden>
    <div class="syllable-picker">
      <label>Select a {dir.srcLabel} syllable:</label>
      <select class="syllable-select" data-dir={dir.key}></select>
    </div>
    <div class="syllable-results"></div>
  </div>
))}

<script is:inline define:vars={{ syllableData: correspondences.syllable }}>
  const state = { direction: 'c2m', component: 'initial' };

  function updateView() {
    // Update button active states
    document.querySelectorAll('.dir-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.dir === state.direction);
    });
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.tab === state.component);
    });

    // Hide all sections
    document.querySelectorAll('.heatmap-section, .syllable-section').forEach(el => {
      el.hidden = true;
    });

    // Show the active section
    if (state.component === 'syllable') {
      const section = document.getElementById(`syllable-${state.direction}`);
      if (section) section.hidden = false;
    } else {
      const section = document.getElementById(`heatmap-${state.direction}-${state.component}`);
      if (section) {
        section.hidden = false;
        const scroller = section.querySelector('.heatmap-scroll');
        const hint = section.querySelector('.scroll-hint');
        if (scroller && hint) {
          hint.hidden = scroller.scrollWidth <= scroller.clientWidth;
        }
      }
    }
  }

  // Direction buttons
  document.querySelectorAll('.dir-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      state.direction = btn.dataset.dir;
      updateView();
    });
  });

  // Component tabs
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      state.component = btn.dataset.tab;
      updateView();
    });
  });

  // Populate syllable dropdowns
  const dirKeys = {
    m2c: 'mandarin_to_cantonese',
    c2m: 'cantonese_to_mandarin',
  };

  document.querySelectorAll('.syllable-select').forEach(select => {
    const dir = select.dataset.dir;
    const lookup = syllableData[dirKeys[dir]];
    const syllables = Object.keys(lookup).sort();

    const defaultOpt = document.createElement('option');
    defaultOpt.value = '';
    defaultOpt.textContent = '-- choose --';
    select.appendChild(defaultOpt);

    syllables.forEach(syl => {
      const opt = document.createElement('option');
      opt.value = syl;
      opt.textContent = syl;
      select.appendChild(opt);
    });

    select.addEventListener('change', () => {
      const resultsDiv = select.closest('.syllable-section').querySelector('.syllable-results');
      const syl = select.value;
      if (!syl) {
        resultsDiv.innerHTML = '';
        return;
      }
      const entry = lookup[syl];
      const srcLabel = dir === 'm2c' ? 'Mandarin' : 'Cantonese';

      let html = `<p class="syllable-total">${entry.total} characters with ${srcLabel} syllable <strong>${syl}</strong></p>`;
      html += '<div class="bar-chart">';
      entry.correspondences.forEach(corr => {
        const width = Math.max(corr.pct, 0.5);
        html += `<div class="bar-row">
          <span class="bar-label">${corr.target || '(none)'}</span>
          <div class="bar-track"><div class="bar-fill" style="width: ${width}%"></div></div>
          <span class="bar-value">${corr.pct}%</span>
          <span class="bar-count">(${corr.count})</span>
        </div>`;
      });
      html += '</div>';
      resultsDiv.innerHTML = html;
    });
  });

  // Hide scroll hints once user scrolls
  document.querySelectorAll('.heatmap-scroll').forEach(scroller => {
    scroller.addEventListener('scroll', () => {
      const hint = scroller.closest('.heatmap-section').querySelector('.scroll-hint');
      if (hint && scroller.scrollLeft > 0) hint.hidden = true;
    }, { passive: true });
  });

  // Show initial view
  updateView();
</script>

</Layout>

<style is:global>
  .stats-table {
    border-collapse: collapse;
    font-size: 1rem;
    margin: 1rem 0 1.5rem;
  }
  .stats-table th, .stats-table td {
    padding: 0.4rem 1rem;
    border-bottom: 1px solid #ddd;
    text-align: left;
  }
  .stats-table th {
    border-bottom: 2px solid #999;
    font-family: 'IM Fell English', serif;
  }
  .stats-table td:nth-child(2), .stats-table td:nth-child(3),
  .stats-table th:nth-child(2), .stats-table th:nth-child(3) {
    text-align: right;
  }
  .stats-table tr:nth-child(odd) {
    background-color: #f2f2f2;
  }

  .byline {
    margin-top: -1.5rem;
    font-size: 1rem;
    color: #666;
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    margin-bottom: 1.5rem;
  }

  .direction-toggle, .component-tabs {
    display: flex;
    gap: 0;
  }

  .direction-toggle button, .component-tabs button {
    padding: 0.5rem 1rem;
    border: 1px solid #999;
    background: #fff;
    cursor: pointer;
    font-family: 'Jost', sans-serif;
    font-size: 0.95rem;
    transition: background-color 0.15s;
  }

  .direction-toggle button:first-child, .component-tabs button:first-child {
    border-radius: 4px 0 0 4px;
  }

  .direction-toggle button:last-child, .component-tabs button:last-child {
    border-radius: 0 4px 4px 0;
  }

  .direction-toggle button + button, .component-tabs button + button {
    border-left: none;
  }

  .direction-toggle button.active, .component-tabs button.active {
    background: rgb(213, 117, 0);
    color: #fff;
    border-color: rgb(213, 117, 0);
  }

  /* Heatmap */
  .matrix-caption {
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 1rem;
  }

  .matrix-caption .lang-name {
    font-weight: bold;
    color: #444;
  }

  .scroll-hint {
    font-size: 0.85rem;
    color: #999;
    font-style: italic;
    text-align: right;
    margin-top: 0.3rem;
    margin-bottom: 0;
  }

  .heatmap-scroll {
    overflow-x: auto;
    margin-bottom: 2rem;
  }

  .heatmap {
    border-collapse: collapse;
    font-size: 0.7rem;
  }

  .heatmap th, .heatmap td {
    padding: 2px 4px;
    text-align: center;
    white-space: nowrap;
  }

  .heatmap .corner {
    background: #ececec;
    border: none;
  }

  .heatmap .top-label {
    background: #ececec;
    font-size: 1.3rem;
    font-family: 'IM Fell English', serif;
    color: rgb(213, 117, 0);
    text-align: center;
    padding-bottom: 2px;
    border: none;
  }

  .heatmap .side-label {
    background: #ececec;
    vertical-align: middle;
    padding: 0 2px;
    border: none;
  }

  .heatmap .side-label-text {
    writing-mode: vertical-rl;
    transform: rotate(180deg);
    font-size: 1.3rem;
    font-family: 'IM Fell English', serif;
    color: rgb(213, 117, 0);
    white-space: nowrap;
  }

  .heatmap .col-header {
    font-weight: bold;
    background: #ececec;
    font-size: 0.8rem;
  }

  .heatmap .row-header {
    font-weight: bold;
    background: #ececec;
    text-align: right;
    padding-right: 8px;
    font-size: 0.8rem;
  }

  .heatmap .cell {
    min-width: 28px;
    height: 24px;
    border: 1px solid #e0e0e0;
    cursor: default;
  }

  /* Syllable section */
  .syllable-picker {
    margin-bottom: 1rem;
  }

  .syllable-picker label {
    margin-right: 0.5rem;
  }

  .syllable-picker select {
    padding: 0.4rem 0.6rem;
    font-size: 1rem;
    font-family: 'Jost', sans-serif;
    border: 1px solid #999;
    border-radius: 4px;
  }

  .syllable-total {
    color: #666;
    margin-bottom: 0.75rem;
  }

  .bar-chart {
    display: flex;
    flex-direction: column;
    gap: 3px;
  }

  .bar-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.9rem;
  }

  .bar-label {
    width: 60px;
    text-align: right;
    font-weight: bold;
    flex-shrink: 0;
  }

  .bar-track {
    flex: 1;
    height: 20px;
    background: #e0e0e0;
    border-radius: 3px;
    overflow: hidden;
  }

  .bar-fill {
    height: 100%;
    background: rgb(213, 117, 0);
    border-radius: 3px;
  }

  .bar-value {
    width: 45px;
    text-align: right;
    flex-shrink: 0;
  }

  .bar-count {
    width: 50px;
    color: #999;
    font-size: 0.8rem;
    flex-shrink: 0;
  }

  @media (max-width: 600px) {
    h1 {
      font-size: 2.3rem;
    }
    .direction-toggle, .component-tabs {
      flex-wrap: wrap;
    }
    .direction-toggle button, .component-tabs button {
      font-size: 0.85rem;
      padding: 0.4rem 0.7rem;
    }
    .heatmap {
      font-size: 0.85rem;
      margin: 0 auto;
    }
    .heatmap .cell {
      min-width: 34px;
      height: 28px;
    }
  }
</style>
